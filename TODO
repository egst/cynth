* fix the syntax error
* sort out test files refering to no longer valid rules.
* include clean-up (careful with asg/declarations)
* check places where return std::move could mess with copy elision
* in functions, prefer explicit return type with generic initializer return over auto return type with explicit initializer return
    i.e. `-> result` and `return {value}` instead of `-> auto` and `return result{value}`
* separate util/general.hpp, and also maybe all the different kinds of results and components (this might speed up compilation time in some cases.)
* don't specify asg:: and ast:: inside those namespaces.
* specify util:: everywhere (even inside util).
* specify interface::, node::, category::, type:: and value:: everywhere.
* f {\n...\n} ()
* rename util::same_as_no_cvref (too long) and util::is (too generic and cryptic).
* decide whether to keep type info in values, or to compute it every time. maybe it could be cashed in an optional value?
* rename util::some, util::none, util::all to be more explicit about what acts on types and what on values.
* type.complete() returns result, but optional makes more sense.
    i think there were complications with vector<optional<result<...>>> kind of thing though
    (vector<result<result<...>>> would colapse into vector<result<...>>)
    yeah maybe i'll keep it the way it is.
    maybe i should restrict return types to result<vector<...>> - not alowing vector<result<...>>
* check if everything is ok with stuff that uses std::vector<bool>
    * or i could use char instead of bool (using cynth::boolean = char) - std::vector<char> is no special case
* rename util::string, util::container
* solve the makefile includes problem
* don't forget about the clang sanitizer and other debug options in the makefile
* use `*std::get_if<T>(variant)` instead of `std::get<T>(variant)` to avoid checking.
    or maybe even that doesn't avoid a check?
* fix util::compose or remove its use everywhere.
* TODO: Decide about implicit conversions.
* in lift for two vectors, iterate over the size of the smallest one to avoid out of bounds access.
    * returning an error now, when trying to iterate over differently sized vectors.
    * TODO: This introduces more mess with result<vector<result<...>>> and similar constructs.
* how to implement fallback overloads in lift without explicit requires (!...)
* stop naming variables `result`, it's confusing when i need refer to the type result as `cynth::result`
* negative indices?
* lambda capture (just copy the whole context for now)
* composed assignment operators
    += -= *= /= **= %= &&= ||=
* *std::move(x) or std::move(*x)?
* how come, that i need to handle delete and new for incomplete component types manually, but it just somehow works for std::vector of incomplete types?
* remove the non-copyable option from categories (it was there only for tighter checks during initial development)
* fix the segfaults with strings not wrapped in components.
* buffers aren't non-const by definition... their elements are non-const, but aren't directly assignable anyways.
    assignment to a buffer would mean a switch to a different generator, which is something that i still haven't thought through completely.
* rename asg::value::(Array|Buffer|In|Out).value->value to something less generic and ambiguous
* automated tests

* cedupoc
* pristuf
