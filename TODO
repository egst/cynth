* fix the syntax error
* sort out test files refering to no longer valid rules.
* include clean-up (careful with sem/declarations)
* check places where return std::move could mess with copy elision
* in functions, prefer explicit return type with generic initializer return over auto return type with explicit initializer return
    i.e. `-> result` and `return {value}` instead of `-> auto` and `return result{value}`
* separate util/general.hpp, and also maybe all the different kinds of results and components (this might speed up compilation time in some cases.)
* don't specify sem:: and ast:: inside those namespaces.
* specify util:: everywhere (even inside util).
* specify interface::, node::, category::, type:: and value:: everywhere.
* f {\n...\n} ()
* rename util::same_as_no_cvref (too long) and util::is (too generic and cryptic).
* decide whether to keep type info in values, or to compute it every time. maybe it could be cashed in an optional value?
* rename util::some, util::none, util::all to be more explicit about what acts on types and what on values.
* type.complete() returns result, but optional makes more sense.
    i think there were complications with vector<optional<result<...>>> kind of thing though
    (vector<result<result<...>>> would colapse into vector<result<...>>)
    yeah maybe i'll keep it the way it is.
    maybe i should restrict return types to result<vector<...>> - not alowing vector<result<...>>
* check if everything is ok with stuff that uses std::vector<bool>
    * or i could use char instead of bool (using cynth::boolean = char) - std::vector<char> is no special case
* rename util::string, util::container
* solve the makefile includes problem
* don't forget about the clang sanitizer and other debug options in the makefile
* use `*std::get_if<T>(variant)` instead of `std::get<T>(variant)` to avoid checking.
    or maybe even that doesn't avoid a check?
* fix util::compose or remove its use everywhere.
* TODO: Decide about implicit conversions.
* in lift for two vectors, iterate over the size of the smallest one to avoid out of bounds access.
    * returning an error now, when trying to iterate over differently sized vectors.
    * TODO: This introduces more mess with result<vector<result<...>>> and similar constructs.
* how to implement fallback overloads in lift without explicit requires (!...)
* stop naming variables `result`, it's confusing when i need refer to the type result as `cynth::result`
* negative indices?
* lambda capture (just copy the whole context for now)
* composed assignment operators
    += -= *= /= **= %= &&= ||=
* *std::move(x) or std::move(*x)?
* how come, that i need to handle delete and new for incomplete component types manually, but it just somehow works for std::vector of incomplete types?
* remove the non-copyable option from categories (it was there only for tighter checks during initial development)
* fix the segfaults with strings not wrapped in components.
* buffers aren't non-const by definition... their elements are non-const, but aren't directly assignable anyways.
    assignment to a buffer would mean a switch to a different generator, which is something that i still haven't thought through completely.
* rename sem::value::(Array|Buffer|In|Out).value->value to something less generic and ambiguous
* automated tests
* iterate over buffers in reverse
* buffer variable should only contain reference to the buffer value and its size
    (which is the size of a view over the buffer, like with arrays),
    while the buffer value should contain the actual values and the generator function.
    this way, the buffers may be passed by references that might refer to a smaller buffer.
* reading input variables should be impossible at compile time.
    passing referential input variables should be possible though.
* lift<variant> instead of lift::variant + lift<tuple, variant> instead of lift::tuple{lift::variant{}} (or the other way around)
* ast:: and sem:: make less sense with all the stuff currently in there.
    ast:: contains abstract syntax tree nodes with some basic interface operating on them and yielding mostly values from sem::.
    sem:: contains abstract semantic graph nodes also with some interface operating on them but also other things.
    A more suiting name would be syn:: and sem:: (instead of ast:: and sem::).
    sem:: (sem::) should somehow be separated into interpretation and translation parts.
    context (and translation_context) can then be moved into sem:: as well.
* value::complete, type::complete is just confusing. change to complete_value to math other things like typed_value.
* detail namespaces begin to collide. specify them locally as `detail::lift`, `detail::iterator` etc.
