Int a = {
    Int b = 5;
    return b + 1;
};

Int f (Int x) x + 1;

Int b = f(5);

Int c = if (b == 5) 1 else 2;

$ ff = Int fn (Int x) x * 2;

# The following functions are equivalent:

(Int, Int) g1 (Int a, Int b) (a + 1, b + 2);

(Int, Int) g2 (Int a, Int b) (a, b) + (1, 2); # Comment.

(Int, Int) g3 ((Int, Int) p) p + (1, 2);

# Another comment.

// These comments work too.

#/* These don't yet. */

# This is not a syntactic error, but it is a semantic one:
# (Only names and tuples of names may appear on the lhs of an assignment.)

(a, f(1)) = (1, 2);

# This is how you define procedures:

() doSomething () { # This one doesn't even take any parameters.
    Bool result1 = doStuff();
    Bool result2 = doOtherStuff();
    when (result1)
        doMoreStuff();
    when (result2) {
        doEvenMoreStuff();
        andSomethingElse();
    }; # Even `}` doesn't allow you to ommit `;`.
    finishingUp();
    return (); # The void expression `()` is implied here.
    return;    # This `;` isn't mandatory here.
}; # Even here the `;` id needed.
# Hopefully, any confusion with the mandatory `;` (concidering the usual approach of C-like syntax languages)
# will be eliminated, once the automatic `;` insertion is implemented.

# This is not possible, even syntactically:
# (Void is a valid type, expression and even declaration, but it may only be used in specific contexts.)
#() v = doSomething()

doSomething(); # The `()` is actually a void expression.

# You can specify the size explicitly:
Int [3]        a = [1, 2, 3];
# Or let it be deduced:
Int [$]        b = [1, 2];
Int []         c = [1, 2, 3];
# Or even capture it in a variable:
Int [Int size] d = [1, 2, 3, 4];
